Develop and Operate Microservices on Kubernetes : Martin Helmich

12th September 2018

https://github.com/PacktPublishing/Develop-and-Operate-Microservices-on-Kubernetes

Installing Minikube:

https://github.com/kubernetes/minikube/releases

$ chmod +X ~/downloads/minikube-linux-amd64

$ sudo mv ~/downloads/minikube-linux-amd64 /usr/local/bin/minikube

$ minikube status

$ minikube start

$ minikube stop

$ minikube delete

Minikube Add-Ons:

Add-Ons enabled by default:
> DNS
> Dashboard
> Storage provisioner

Add-Ons NOT enabled by default:
> Ingress
> Heapster

$ minikube addons enable ingress

$ minikube addons enable heapster


Pods - The Basic Deployment Unit
> Multiple containers scheduled on the same node
> Shared network namespaces for all containers in the Pod

Namespaces - Resource Grouping and Isolation
> Purely virtual for grouping resources
> Two namespaces in a fresh Kubernetes cluster: default and kube-system
> No additional isolation at container level

imagePullSecret:
Option for authenticating docker pull from private registries

apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: default
spec:
  containers:
      name: service
      image: nginx
      ports:
        - containerPort: 80
      env:
        - name: SOME_ENV_VAR
          value: Hello World


> Each Pod is assigned to a specific Node in the cluster
> If a Pod crashes, it will be restarted
> If a Node crashes, Pods running on it will be lost as well


Higher Level Kubernetes Resources:
1. ReplicaSet
2. Deployment
3. StatefulSet

ReplicaSet
> Manages Pods
> Self-healing and Scalable

Deployment
> Manages ReplicaSets
> Rolling updates and rollbacks

StatefulSet
> Similar to ReplicaSet
> Pods have stable network identity
> Pods have a startup order


Labels:
Every object can have arbitrary number of labels
We can use labels to query and filter objects

$ kubectl get pods -l app=my-app


ReplicaSet Properties
1. Pod template
  > Definition for Pods that are managed by this ReplicaSet
2. Replica count
  > Defines how many instances of the Pod should be running at any time
3. Label Selector
  > Determines which Pods are manaed by the ReplicaSet

Example:
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: service
        image: nginx

$ kubectl apply -f replicaset.yaml

Pod Networking:
> Pods have IP addresses
> Pod IPs are routable within the cluster (no external connectivity)
< Pods are short-lived
< Addresses may change frequently
< No DNS for Pod IPs
< No load balancing

Services:
> Selects a set of Pods by label
> One stable IP and DNS name for a group of Pods
> Round-robin load balancing
> Automatically adds/removes Pods as they come and go
> DNS name: my-service.services.cluster.local

Discovering Services:

Environment Variables
Kubelet adds a set of environment variables to the Pod for each active Service in the cluster.
{SVCNAME}_SERVICE_HOST and {SVCNAME}_SERVICE_PORT where the Service name is uppercased and any dashes are converted to underscores
e.g. Service named "redis-master" will create the below environment variables inside the Pods
REDIS_MASTER_SERVICE_HOST=10.0.0.11
REDIS_MASTER_SERVICE_PORT=6379

Any Service that a Pod wants to access MUST BE CREATED BEFORE the Pod itself,
otherwise the environment variables will not be populated

DNS Service Discovery:
Provided by DNS Server cluster add-on which watches the Kubernetes API for new Services
DNS Server creates a set of DNS records for each new Service
All Pods are able to resolve the Service name automatically

E.g. If we have a Service named "my-service" in Namespace "my-ns", then a DNS record for "my-service-my-ns" is created.
Pods in the "my-ns" Namespace are able to do name lookup fo "my-service"
Pods in other Namespaces must qualify the name as "my-service-my-ns"

https://kubernetes.io/docs/concepts/services-networking/service/

https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types

ClusterIP Service:
> Stable internal IP
> Stable internal DNS
> Routed within the cluster
> Can be used by Pods in the cluster to connect to the Pods selected by a Service

NodePort Service:
> A ClusterIP Service is created
> Every Node gets a public TCP port forwarding to that ClusterIP Service

LoadBalancer Service:
> A NodePort Service is created
> Additionally a load balancer is created to allow external incomming traffic


Example:
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ClusterIP
  selector:
    app: my-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80

$ kubectl apply -f service.yaml

$ kubectl get services

$ kubectl run --rm -it --image=alpine my-test
# apk -U add curl
...
# curl -v my-service
...
This shows that we can access the service by simply using its name from other Pods in the same Namespace

FQDN: service-name.namespace-name.svc.cluster.local

Example Load Balancer Service:
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: LoadBalancer
  selector:
    app: my-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80


HTTP Connectivity with Ingress:

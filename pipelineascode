Jenkins Pipeline as Code

1. Declarative Pipeline
2. Scripted Pipeline

More about Pipeline Syntax: https://jenkins.io/doc/book/pipeline/syntax/

Declarative Pipeline syntax alwasys starts with the keyword "pipeline"
Scripted Pipeline syntax always starts with keyword "node"

We can still use "script block" inside Declarative Pipeline

Simple Hello World pipeline:

pipeline{
    agent any
    stages{
        stage("Hello"){
            steps{
                echo "Hello World"
            }
        }
    }
}

If we specify agent as "none" in the above pipeline example, then it will run on the Jenkins master

If we have a Jenkins slave node named "Slave 1", then we can specify label to run the pipeline on that slave

pipeline{
    agent{
        label "Slave 1"
    }
    stages{
        stage("Hello"){
            steps{
                echo "Hello World"
            }
        }
    }
}

This will run the pipeline on Jenkins slave named "Slave 1"


Custom Workspace:
We can specify a custom workspace for our pipeline by using customworkspace attribute of agent as in the below example...

pipeline{
    agent{
        label "Slave 1"
        customworkspace "/home/ec2-user/customworkspace"
    }
    stages{
        stage("Hello"){
            steps{
                echo "Hello World"
            }
        }
    }
}


Script Block:
We can use script block to run groovy scripts inside out declarative pipeline as below...

pipeline{
    agent any
    stages{
        stage('Build'){
            steps{
                script{
                    def name = "jesse"
                    
                    if(name == "jesse")
                        println("Hi ${name}")
                    else
                        println("Hi human")
                    
                    sleep 2
                    echo "end of script"
                }
            }
        }
    }
}

Here the "sleep" and "echo" steps in the above pipeline comes from "Workflow Basic Steps" plugin

More about Workflow Basic Steps: https://jenkins.io/doc/pipeline/steps/workflow-basic-steps/


Error, Retry and Timeout:

"retry" and "timeout" only apply to a block of code
"retry" and "timeout" can be used seperately or nested within each other as well.

Like "sleep" and "echo", "retry" and "timeout" are also provided by "Workflow Basic Steps" plugin

Retry:
======

pipeline{
    agent any
    stages{
        stage('Build'){
            steps{
                retry(3) {
                    echo "Before throwing error"
                    error "error in retry"
                }
                echo "end of script"
            }
        }
    }
}

Timeout:
========

pipeline{
    agent any
    stages{
        stage('Build'){
            steps{
                timeout(time: 1, unit: 'SECONDS'){
                    echo "Sleeping in timeout"
                    sleep 2
                }
            }
        }
    }
}

Here the sleep will be aborted due to timeout

Nested Retry and Timeout:
=========================

pipeline{
    agent any
    stages{
        stage('Build'){
            steps{
                retry(3) {
                    timeout(time: 1, unit: 'SECONDS'){
                        sleep 2
                    }
                    echo "After timeout"
                }
            }
        }
    }
}

Here the timeout block is retried three times and the pipeline is aborted, echo never executes

Tools:
======
A section in the pipeline defining tools to auto-install and put on the PATH
This instruction is ignored if agent is specified as none
We can add the tools section either under stage or directly under pipeline

Tools refered to by the tools section should already be available in Global Tool Configuration
Manage Jenkins => Global Tool Configuration

pipeline {
    agent any
    
    stages {
        stage('Build') {
            tools {
                maven 'maven3_5_2'
            }
            steps {
                sh 'mvn --version'
            }
        }
    }
}

If we had two different versions of maven installed,
then we can instruct the pipeline to use a specific version of maven by using the tools section


Error, Options, and Retry:
==========================

pipeline {
    agent any
    stages {
        stage('Build') {
            options {
                retry(3)
            }
            steps {
                echo "Before error statement"
                error "Error statement just got executed"
                echo "After error statement"
            }
        }
    }
}

This pipeline retries three times and aborts without printing "After error statement"

pipeline {
    agent any
    stages {
        stage('Build') {
            options {
                retry(3)
            }
            steps {
                echo "Before setting current build to FAILURE"
                script {
                    currentBuild.result = 'FAILURE'
                }
                echo "After setting the current build to FAILURE"
            }
        }
    }
}

This pipeline sets the current build to failure, and it does not retry
Also this pipeline prints "After setting the current build to FAILURE"

Options and Timeout:
====================

Steps in the Options directive are invoked before entering the agent, or checking any when conditions

pipeline {
    agent any
    stages {
        stage('Build') {
            options {
                timeout(time: 1, unit: 'SECONDS')
            }
            steps {
                echo 'Hello World'
                sleep 2
            }
        }
    }
}

This pipeline timesout after printing Hello World

Timestamp Console Output:
=========================

pipeline {
    agent any
    stages {
        stage('Build') {
            options {
                timestamps()
            }
            steps {
                echo "Hello World in Build"
                echo "Hello World in Build Again"
            }
        }
        
        stage('Test') {
            steps {
                echo "Hello World in Test"
                echo "Hello World in Test Again"
            }
        }
    }
}

Here we have the timestamps() option for the Build stage, but not for Test stage
We will see the timestamp being prefixed before the console output of Build stage

pipeline {
    agent any
    
    options {
        timestamps()
    }
    
    stages {
        stage('Build') {
            steps {
                echo "Hello World in Build"
                echo "Hello World in Build Again"
            }
        }
        
        stage('Test') {
            steps {
                echo "Hello World in Test"
                echo "Hello World in Test Again"
            }
        }
    }
}

Here we have moved the Options block to pipeline level, so we should see timestamps for output of all the stages

skipDefaultCheckout:
====================
Skip checking out code from source control by default in the agent directive (stage level and pipeline level)

This option prevents the checking out of source code from the repository automatically

First: We will have to create a github credentials in jenkins

Credentials -> System -> Global Credentials -> Add Credentials

pipeline {
    agent none
  
    stages {
        stage('Build') {
            agent any
            options {
                skipDefaultCheckout()
            }
          
            steps {
              echo "Hello World"
            }
        }
    }
}

This pipeline will not checkout the source code from git repository

If we set "agent any" at pipeline level, then the skipDefaultCheckout option at the stage level does not have any effect.


pipeline {
    agent any
        options {
            skipDefaultCheckout()
        }
  
    stages {
        stage('Build') {
            agent any          
            steps {
              echo "Hello World"
            }
        }
    }
}

Here the skipDefaultCheckout option is set at pipeline level, and will be enforced

Pipeline, Stages and Environment Variables:
===========================================

pipeline {
    agent any
    
    environment {
        name1 = "Jesse"
        name2 = "Simon"
    }
    
    stages {
    
        stage('Build') {
        
            environment {
                name3 = "Jaimie"
            }
            
            steps {
                echo "name1 ${name1}"
                echo "name2 ${name2}"
                echo "name3 ${name3}"    
            }
        }
    }
}

This pipeline prints all three names from the echo statement

pipeline {
    agent any
    
    environment {
        name1 = "Jesse"
        name2 = "Simon"
    }
    
    stages {
    
        stage('Build') {
        
            environment {
                name3 = "Jaimie"
            }
            
            steps {
                echo "name1 ${name1}"
                echo "name2 ${name2}"
                echo "name3 ${name3}"    
            }
            
        }
        
         stage('Test') {
            
            steps {
                echo "name1 ${name1}"
                echo "name2 ${name2}"
                echo "name3 ${name3}"    
            }
            
        }
    }
}

This pipeline will fail with the below exception as name3 is not available in Test stage
groovy.lang.MissingPropertyException: No such property: name3 for class: groovy.lang.Binding

pipeline {
    agent any
    
    environment {
        name1 = "Jesse"
        name2 = "Simon"
    }
    
    stages {
    
        stage('Build') {
        
            environment {
                name2 = "Mike"
                name3 = "Jaimie"
            }
            
            steps {
                echo "name1 ${name1}"
                echo "name2 ${name2}"
                echo "name3 ${name3}"    
            }
        }
    }
}

Here name2 is printed as "Mike", environment variable at the stage level takes precedence over environment variable at pipeline level

pipeline {
    agent any
    
    environment {
        name1 = "Jesse"
        name2 = "Simon"
    }
    
    stages {
    
        stage('Build') {
        
            environment {
                name3 = "Jaimie"
            }
            
            steps {
                sh "printenv"
            }
        }
    }
}

Here we have a sh "shell" step in Build stage from workflow durable task step plugin.
https://jenkins.io/doc/pipeline/steps/workflow-durable-task-step/

Here we are using printenv to print out the environment variables from the shell script
We can see name1, name2, and name3 among the bunch of environment variables printed by printenv


Credentials in Pipeline:
========================

Lets create few dummy credentials...

Credentials => System => Global Credentials => Add credentials => Username with password
=> Enter username and password and use "some_username_password" as ID

Credentials => System => Global Credentials => Add credentials => Secret text
=> Scope = Global, Secret = "mysecret" ID = some_secret

pipeline {
    agent any
    
    stages {
    
        stage('Build') {
        
            environment {
                SOME_USERNAME_PASSWORD = credentials('some_username_password')
                SOME_SECRET = credentials('some_secret')
            }
            
            steps {
                echo "SOME_USERNAME_PASSWORD ${SOME_USERNAME_PASSWORD}" // this is in the format of username:password
                echo "SOME_USERNAME_PASSWORD_USR ${SOME_USERNAME_PASSWORD_USR}"
                echo "SOME_USERNAME_PASSWORD_PSW ${SOME_USERNAME_PASSWORD_PSW}"
                echo "SOME_SECRET ${SOME_SECRET}"
            }
        }
    }
}


Pipeline Stage -> When:
=======================

pipeline {
    agent any
    
    environment {
        DEPLOY_TO='production'
    }
    
    stages {
        stage('Build') {
            when {
                environment name: 'DEPLOY_TO', value: 'production'
            }
            steps {
                echo 'Deploying'
            }
        }
    }
}

This pipeline prints out 'Deploying'

pipeline {
    agent any
    
    environment {
        DEPLOY_TO='test'
    }
    
    stages {
        stage('Build') {
            when {
                environment name: 'DEPLOY_TO', value: 'production'
            }
            steps {
                echo 'Deploying'
            }
        }
    }
}

Stage 'Build' skipped due to when conditional


When with equals:
=================

pipeline {
    agent any
    
    environment {
        some_name="jesse"
    }
    
    stages {
        stage('Build') {
            when {
                equals expected: "jesse", actual: somae_name
            }
            steps {
                echo "${some_name}"
            }
        }
    }
}

When with not:
==============

pipeline {
    agent any
    
    environment {
        some_name="john"
    }
    
    stages {
        stage('Build') {
            when {
                not {
                    equals expected: "jesse", actual: somae_name
                }
            }
            steps {
                echo "${some_name}"
            }
        }
    }
}

Here we have nested the equals conditional inside the not conditional

